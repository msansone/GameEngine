/* -------------------------------------------------------------------------
** AudioPlayer.hpp
** 
** The AudioPlayer class is an abstract class from which classes for specific 
** audio libraries are to be derived. It is used to store and play all audio resources.
**
** Author: Mike Sansone
** ------------------------------------------------------------------------- */

#ifndef _AUDIOPLAYER_HPP_
#define _AUDIOPLAYER_HPP_

#if defined(FIREMELON_EXPORTS)
#   define FIREMELONAPI   __declspec(dllexport)
#else
#   define FIREMELONAPI   __declspec(dllimport)
#endif  // FIREMELON_EXPORTS

#include <boost/shared_ptr.hpp>

#include "BaseIds.hpp"
#include "Vec2.hpp"

#include <string>
#include <map>

namespace firemelon
{
	class FIREMELONAPI AudioPlayer 
	{
	public:
		friend class Assets;
		friend class Room;

		AudioPlayer();
		virtual ~AudioPlayer();
	
		virtual void	initialize() {}; // = 0; // This should be abstract, but VS2015 breaks boost python for some reason, and this is now needed as a workaround.
		virtual void	shutdown() {}; // = 0; // Likewise with this, as well as other methods in this class.
		virtual void	update();
	
		// Loads an audio resource from a byte array.
		virtual int		loadAudioResource(std::string audioname, char* buffer, int bufferSize, std::string groupName) { assert(false); return -1; }; // = 0;	

		// Loads from an audio resource from a file.
		virtual int		loadAudioResource(std::string audioname, std::string filename, std::string groupName) { assert(false); return -1; }; // = 0;	
		
		void			playAudioByNamePy(std::string audioName, float volume, bool loop);
		void			playAudioByName(std::string audioName, float volume, bool loop);
		
		void			stopAudioByNamePy(std::string audioName);
		void			stopAudioByName(std::string audioName);

		virtual void	playAudio(int audioId, float volume, bool loop) { assert(false); }; // = 0;

		virtual void	playAudio(int audioId, float volume, bool loop, double x, double y, int minDistance, int maxDistance) {}; // = 0;
		virtual void	stopAudio(int audioId) { assert(false); }; // = 0;
	
		void			stopAllAudioPy();
		virtual void	stopAllAudio() { assert(false); }; // = 0;
		
		void			setPauseAllAudioPy(bool isPaused);
		virtual void	setPauseAllAudio(bool isPaused) { assert(false); }; // = 0;

		bool			isAudioPlayingByIndexPy(int audioIndex);
		virtual bool	isAudioPlayingByIndex(int audioIndex) { assert(false); return false; }; // = 0;

		bool			isAudioPlayingByNamePy(std::string audioName);
		virtual bool	isAudioPlayingByName(std::string audioName) { assert(false); return false; }; // = 0;

		void			setGroupVolumePy(std::string groupName, float volume);
		virtual void	setGroupVolume(std::string groupName, float volume);
		
		double			getGroupVolumePy(std::string groupName);
		virtual double	getGroupVolume(std::string groupName);
		
		int				translateAudioId(AssetId editorAudioId);

	protected:
		
		float getListenerX();
		float getListenerY();

		std::map<std::string, int>	audioNameIDMap_;
		
		// Map the audio ID from the room file to the audio ID in the player. 
		// This is because the ID stored in the player is not guaranteed to be the 
		// same as the the ID generated by the engine.
		std::map<AssetId, int> audioIdMap_;

	private:
		
		boost::shared_ptr<Vec2<float>>	listenerPosition_;
		boost::shared_ptr<Vec2<float>>	listenerPositionOffset_;
	};

	typedef boost::shared_ptr<AudioPlayer> AudioPlayerPtr;
}
#endif // _AUDIOPLAYER_HPP_